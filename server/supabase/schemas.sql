-- Updated schemas for InfluencerFlow database
-- Based on actual Supabase database structure from MCP analysis

-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- ============ TABLE DEFINITIONS ============

-- Brands table
CREATE TABLE public.brands (
  id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  brand_name text,
  brand_description text,
  location text,
  brand_id uuid NOT NULL,
  CONSTRAINT brands_pkey PRIMARY KEY (id),
  CONSTRAINT brands_brand_id_key UNIQUE (brand_id),
  CONSTRAINT brands_brand_id_fkey FOREIGN KEY (brand_id) REFERENCES auth.users(id)
) TABLESPACE pg_default;

COMMENT ON TABLE public.brands IS 'Table storing brand profiles linked to auth users';

-- Campaign table
CREATE TABLE public.campaign (
  id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  brand_id uuid,
  campaign_name text,
  description text,
  platforms text,
  preferred_languages text,
  budget numeric,
  start_date date,
  end_date date,
  status text DEFAULT 'draft'::text,
  report_id uuid,
  voice_enabled boolean DEFAULT false,
  brand_name text,
  updated_at timestamp with time zone DEFAULT now(),
  final_price numeric,
  contract_id uuid,
  CONSTRAINT campaign_pkey PRIMARY KEY (id),
  CONSTRAINT campaign_brand_id_fkey FOREIGN KEY (brand_id) REFERENCES auth.users(id),
  CONSTRAINT campaign_contract_id_fkey FOREIGN KEY (contract_id) REFERENCES contracts(id)
) TABLESPACE pg_default;

COMMENT ON TABLE public.campaign IS 'Marketing campaigns created by brands';
COMMENT ON COLUMN public.campaign.status IS 'Status can be: draft, active, in_review, completed, declined';

-- Create trigger for campaign updated_at
CREATE OR REPLACE FUNCTION update_campaign_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_campaign_updated_at_trigger
BEFORE UPDATE ON campaign
FOR EACH ROW
EXECUTE FUNCTION update_campaign_updated_at();

-- Influencers table
CREATE TABLE public.influencers (
  id uuid DEFAULT gen_random_uuid() NOT NULL,
  influencer_username text NOT NULL,
  created_at timestamp with time zone DEFAULT now(),
  influencer_email text NOT NULL,
  influencer_followers integer,
  platforms text,
  bio text,
  CONSTRAINT influencers_pkey PRIMARY KEY (id),
  CONSTRAINT influencers_influencer_email_key UNIQUE (influencer_email)
) TABLESPACE pg_default;

COMMENT ON TABLE public.influencers IS 'Influencer profiles that can be contacted for campaigns';

-- Contracts table
CREATE TABLE public.contracts (
  id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
  template_id text NOT NULL,
  influencer_id uuid NOT NULL,
  brand_id uuid NOT NULL,
  status text NOT NULL,
  contract_data jsonb NOT NULL,
  signed_by uuid,
  signed_at timestamp with time zone,
  signature_url text,
  contract_url text,
  payment_status text,
  payment_id text,
  razorpay_order_id text,
  created_at timestamp with time zone DEFAULT now(),
  updated_at timestamp with time zone DEFAULT now(),
  CONSTRAINT contracts_pkey PRIMARY KEY (id),
  CONSTRAINT contracts_brand_id_fkey FOREIGN KEY (brand_id) REFERENCES auth.users(id),
  CONSTRAINT contracts_signed_by_fkey FOREIGN KEY (signed_by) REFERENCES auth.users(id),
  CONSTRAINT contracts_status_check CHECK (
    status = ANY (ARRAY[
      'DRAFT'::text,
      'PENDING_SIGNATURE'::text,
      'SIGNED'::text,
      'REJECTED'::text
    ])
  ),
  CONSTRAINT contracts_payment_status_check CHECK (
    payment_status IS NULL OR payment_status = ANY (ARRAY[
      'PENDING'::text,
      'INITIATED'::text,
      'COMPLETED'::text,
      'FAILED'::text
    ])
  )
) TABLESPACE pg_default;

COMMENT ON TABLE public.contracts IS 'Legal agreements between brands and influencers';
COMMENT ON COLUMN public.contracts.contract_data IS 'JSON containing contract details like rate, timeline, deliverables, etc.';

-- Create indexes for contracts table
CREATE INDEX idx_contracts_brand_id ON public.contracts USING btree (brand_id) TABLESPACE pg_default;
CREATE INDEX idx_contracts_influencer_id ON public.contracts USING btree (influencer_id) TABLESPACE pg_default;
CREATE INDEX idx_contracts_status ON public.contracts USING btree (status) TABLESPACE pg_default;
CREATE INDEX idx_contracts_payment_status ON public.contracts USING btree (payment_status) TABLESPACE pg_default;

-- Create trigger for updated_at column in contracts
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_updated_at
BEFORE UPDATE ON contracts
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Outreach table
CREATE TABLE public.outreach (
  id uuid DEFAULT gen_random_uuid() NOT NULL,
  campaign_id integer,
  influencer_id uuid NOT NULL,
  influencer_username character varying NOT NULL,
  influencer_email character varying NOT NULL,
  influencer_followers integer DEFAULT 0,
  brand_id character varying NOT NULL,
  email_subject text,
  email_body text,
  status character varying DEFAULT 'sent'::character varying,
  sent_at timestamp with time zone DEFAULT now(),
  replied_at timestamp with time zone,
  created_at timestamp with time zone DEFAULT now(),
  updated_at timestamp with time zone DEFAULT now(),
  agreed_price numeric,
  contract_id uuid,
  CONSTRAINT outreach_pkey PRIMARY KEY (id),
  CONSTRAINT outreach_campaign_id_fkey FOREIGN KEY (campaign_id) REFERENCES campaign(id),
  CONSTRAINT outreach_contract_id_fkey FOREIGN KEY (contract_id) REFERENCES contracts(id),
  CONSTRAINT outreach_status_check CHECK (
    status::text = ANY (ARRAY[
      'sent'::character varying::text, 
      'pending'::character varying::text, 
      'replied'::character varying::text, 
      'declined'::character varying::text, 
      'completed'::character varying::text
    ])
  )
) TABLESPACE pg_default;

COMMENT ON TABLE public.outreach IS 'Tracks all outreach activities to influencers';
COMMENT ON COLUMN public.outreach.influencer_followers IS 'Follower count at time of outreach';
COMMENT ON COLUMN public.outreach.status IS 'Status can be: sent, pending, replied, declined, completed';

-- CRM_logs table
CREATE TABLE public."CRM_logs" (
  id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  campaign_id bigint,
  content jsonb[],
  influencer_id uuid,
  CONSTRAINT CRM_logs_pkey PRIMARY KEY (id),
  CONSTRAINT CRM_logs_campaign_id_fkey FOREIGN KEY (campaign_id) REFERENCES campaign(id)
) TABLESPACE pg_default;

COMMENT ON TABLE public."CRM_logs" IS 'Stores conversation history and notes for influencer interactions';
COMMENT ON COLUMN public."CRM_logs".content IS 'Array of JSON objects containing conversation entries';

-- ============ FUNCTION DEFINITIONS ============

-- Function to check if user exists by email
CREATE OR REPLACE FUNCTION public.check_user_exists(user_email text)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  found_user_id uuid;
  result json;
BEGIN
  -- Look for the user in auth.users table
  SELECT id INTO found_user_id
  FROM auth.users
  WHERE email = user_email
  LIMIT 1;
  
  -- Build the result JSON object
  IF found_user_id IS NOT NULL THEN
    result := json_build_object(
      'exists', true,
      'user_id', found_user_id
    );
  ELSE
    result := json_build_object(
      'exists', false,
      'user_id', NULL
    );
  END IF;
  
  RETURN result;
END;
$function$;

-- Function to create a provisional user for contracts
CREATE OR REPLACE FUNCTION public.create_provisional_user(user_email text, user_name text)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  new_user_id uuid;
  result json;
BEGIN
  -- First check if user already exists to avoid duplicate errors
  SELECT id INTO new_user_id
  FROM auth.users
  WHERE email = user_email
  LIMIT 1;
  
  IF new_user_id IS NOT NULL THEN
    -- User already exists, return existing data
    result := json_build_object(
      'id', new_user_id,
      'email', user_email,
      'name', user_name,
      'new_user', false
    );
  ELSE
    -- Generate a new UUID for the user
    new_user_id := gen_random_uuid();
    
    -- Insert the user into auth.users with minimal required fields
    INSERT INTO auth.users (
      id, 
      email, 
      raw_user_meta_data, 
      role,
      created_at,
      updated_at,
      is_anonymous,
      email_confirmed_at
    ) VALUES (
      new_user_id,
      user_email,
      json_build_object('full_name', user_name, 'is_provisional', true, 'provider', 'provisional'),
      'authenticated',
      now(),
      now(),
      false,
      now() -- Auto-confirm email to avoid validation issues
    );
    
    -- Return the created user data
    result := json_build_object(
      'id', new_user_id,
      'email', user_email,
      'name', user_name,
      'new_user', true
    );
  END IF;
  
  RETURN result;
EXCEPTION
  WHEN OTHERS THEN
    RAISE EXCEPTION 'Failed to create or find user: %', SQLERRM;
END;
$function$;

-- Function to bypass contract creation constraints (used in the application)
CREATE OR REPLACE FUNCTION public.bypass_contract_creation(
  contract_id uuid,
  template_id text,
  influencer_id uuid,
  brand_id uuid,
  contract_data jsonb,
  status text DEFAULT 'PENDING_SIGNATURE'::text
)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  result_id uuid;
BEGIN
  INSERT INTO contracts (
    id,
    template_id,
    influencer_id,
    brand_id,
    status,
    contract_data,
    created_at,
    updated_at
  ) VALUES (
    contract_id,
    template_id,
    influencer_id,
    brand_id,
    status,
    contract_data,
    now(),
    now()
  ) RETURNING id INTO result_id;
  
  RETURN result_id;
EXCEPTION
  WHEN OTHERS THEN
    RAISE EXCEPTION 'Error creating contract: %', SQLERRM;
END;
$function$;

-- Function to safely check if an email exists
CREATE OR REPLACE FUNCTION public.safe_check_email(email text)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  found_influencer record;
  found_user record;
  result json;
BEGIN
  -- Check influencers table
  SELECT id, influencer_username
  INTO found_influencer
  FROM influencers
  WHERE influencer_email = email
  LIMIT 1;
  
  -- Check auth.users table
  SELECT id, raw_user_meta_data->>'full_name' as full_name
  INTO found_user
  FROM auth.users
  WHERE email = email
  LIMIT 1;
  
  -- Build result
  result := json_build_object(
    'exists_as_influencer', found_influencer IS NOT NULL,
    'exists_as_user', found_user IS NOT NULL,
    'influencer_id', found_influencer.id,
    'influencer_name', found_influencer.influencer_username,
    'user_id', found_user.id,
    'user_name', found_user.full_name
  );
  
  RETURN result;
END;
$function$;

-- Create contract with temp user function
CREATE OR REPLACE FUNCTION public.create_contract_with_temp_user(
  contract_uuid uuid,
  template_id_val text,
  influencer_email_val text,
  influencer_name_val text,
  brand_id_val uuid,
  contract_data_val jsonb
)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  influencer_id_val uuid;
  result json;
BEGIN
  -- First check if influencer already exists
  SELECT id INTO influencer_id_val
  FROM influencers
  WHERE influencer_email = influencer_email_val
  LIMIT 1;
  
  -- If not, create a new influencer
  IF influencer_id_val IS NULL THEN
    INSERT INTO influencers (
      id,
      influencer_username,
      influencer_email
    ) VALUES (
      gen_random_uuid(),
      influencer_name_val,
      influencer_email_val
    ) RETURNING id INTO influencer_id_val;
  END IF;
  
  -- Create the contract
  INSERT INTO contracts (
    id,
    template_id,
    influencer_id,
    brand_id,
    status,
    contract_data,
    created_at,
    updated_at
  ) VALUES (
    contract_uuid,
    template_id_val,
    influencer_id_val,
    brand_id_val,
    'PENDING_SIGNATURE',
    contract_data_val,
    now(),
    now()
  );
  
  -- Return result
  result := json_build_object(
    'contract_id', contract_uuid,
    'influencer_id', influencer_id_val,
    'brand_id', brand_id_val,
    'status', 'PENDING_SIGNATURE'
  );
  
  RETURN result;
EXCEPTION
  WHEN OTHERS THEN
    RAISE EXCEPTION 'Error creating contract with temp user: %', SQLERRM;
END;
$function$;